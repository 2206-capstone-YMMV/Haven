{"ast":null,"code":"import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";import{CodedError}from'expo-modules-core';var GOOGLE_API_URL='https://maps.googleapis.com/maps/api/geocode/json';var googleApiKey;export function setGoogleApiKey(apiKey){googleApiKey=apiKey;}export function googleGeocodeAsync(_x){return _googleGeocodeAsync.apply(this,arguments);}function _googleGeocodeAsync(){_googleGeocodeAsync=_asyncToGenerator(function*(address){assertGoogleApiKey();var result=yield requestGoogleApiAsync({address:address});if(result.status==='ZERO_RESULTS'){return[];}assertGeocodeResults(result);return result.results.map(geocodingResultToLocation);});return _googleGeocodeAsync.apply(this,arguments);}export function googleReverseGeocodeAsync(_x2){return _googleReverseGeocodeAsync.apply(this,arguments);}function _googleReverseGeocodeAsync(){_googleReverseGeocodeAsync=_asyncToGenerator(function*(options){assertGoogleApiKey();var result=yield requestGoogleApiAsync({latlng:options.latitude+\",\"+options.longitude});if(result.status==='ZERO_RESULTS'){return[];}assertGeocodeResults(result);return result.results.map(reverseGeocodingResultToAddress);});return _googleReverseGeocodeAsync.apply(this,arguments);}function assertGeocodeResults(resultObject){var status=resultObject.status,error_message=resultObject.error_message;if(status!=='ZERO_RESULTS'&&status!=='OK'){if(error_message){throw new CodedError(status,error_message);}else if(status==='UNKNOWN_ERROR'){throw new CodedError(status,'the request could not be processed due to a server error. The request may succeed if you try again.');}throw new CodedError(status,\"An error occurred during geocoding.\");}}function assertGoogleApiKey(){if(!googleApiKey){throw new Error('Google API key is required to use geocoding. Please set it using `setGoogleApiKey` method.');}}function requestGoogleApiAsync(_x3){return _requestGoogleApiAsync.apply(this,arguments);}function _requestGoogleApiAsync(){_requestGoogleApiAsync=_asyncToGenerator(function*(params){var query=Object.entries(params).map(function(entry){return entry[0]+\"=\"+encodeURI(entry[1]);}).join('&');var result=yield fetch(GOOGLE_API_URL+\"?key=\"+googleApiKey+\"&\"+query);return yield result.json();});return _requestGoogleApiAsync.apply(this,arguments);}function geocodingResultToLocation(result){var location=result.geometry.location;return{latitude:location.lat,longitude:location.lng};}function reverseGeocodingResultToAddress(result){var address={};for(var _ref of result.address_components){var long_name=_ref.long_name;var short_name=_ref.short_name;var types=_ref.types;if(types.includes('locality')){address.city=long_name;continue;}if(types.includes('sublocality')){address.district=long_name;continue;}if(types.includes('street_number')){address.streetNumber=long_name;continue;}if(types.includes('street_address')||types.includes('route')){address.street=long_name;continue;}if(types.includes('administrative_area_level_1')){address.region=long_name;continue;}if(types.includes('administrative_area_level_2')){address.subregion=long_name;continue;}if(types.includes('country')){address.country=long_name;address.isoCountryCode=short_name;continue;}if(types.includes('postal_code')){address.postalCode=long_name;continue;}if(types.includes('point_of_interest')){address.name=long_name;continue;}}if(!address.name){address.name=result.formatted_address.replace(/,.*$/,'');}return address;}","map":{"version":3,"mappings":"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","names":["CodedError","GOOGLE_API_URL","googleApiKey","setGoogleApiKey","apiKey","googleGeocodeAsync","address","assertGoogleApiKey","result","requestGoogleApiAsync","status","assertGeocodeResults","results","map","geocodingResultToLocation","googleReverseGeocodeAsync","options","latlng","latitude","longitude","reverseGeocodingResultToAddress","resultObject","error_message","Error","params","query","Object","entries","entry","encodeURI","join","fetch","json","location","geometry","lat","lng","address_components","long_name","short_name","types","includes","city","district","streetNumber","street","region","subregion","country","isoCountryCode","postalCode","name","formatted_address","replace"],"sourceRoot":"","sources":["../src/LocationGoogleGeocoding.ts"],"sourcesContent":["import { CodedError } from 'expo-modules-core';\n\nimport { LocationGeocodedAddress, LocationGeocodedLocation } from './Location.types';\n\nconst GOOGLE_API_URL = 'https://maps.googleapis.com/maps/api/geocode/json';\nlet googleApiKey;\n\ntype GoogleApiGeocodingAddressComponent = {\n  long_name: string;\n  short_name: string;\n  types: string[];\n};\n\ntype GoogleApiGeocodingResult = {\n  address_components: GoogleApiGeocodingAddressComponent[];\n  formatted_address: string;\n  geometry: {\n    location: {\n      lat: number;\n      lng: number;\n    };\n  };\n};\n\ntype GoogleApiGeocodingResponse = {\n  results: GoogleApiGeocodingResult[];\n  status: string;\n};\n\n// @needsAudit\n/**\n * Sets a Google API Key for using Google Maps Geocoding API which is used by default on Web\n * platform and can be enabled through `useGoogleMaps` option of `geocodeAsync` and `reverseGeocodeAsync`\n * methods. It might be useful for Android devices that do not have Google Play Services, hence no\n * Geocoder Service.\n * @param apiKey Google API key obtained from Google API Console. This API key must have `Geocoding API`\n * enabled, otherwise your geocoding requests will be denied.\n */\nexport function setGoogleApiKey(apiKey: string) {\n  googleApiKey = apiKey;\n}\n\nexport async function googleGeocodeAsync(address: string): Promise<LocationGeocodedLocation[]> {\n  assertGoogleApiKey();\n\n  const result = await requestGoogleApiAsync({ address });\n\n  if (result.status === 'ZERO_RESULTS') {\n    return [];\n  }\n  assertGeocodeResults(result);\n  return result.results.map(geocodingResultToLocation);\n}\n\nexport async function googleReverseGeocodeAsync(options: {\n  latitude: number;\n  longitude: number;\n}): Promise<LocationGeocodedAddress[]> {\n  assertGoogleApiKey();\n\n  const result = await requestGoogleApiAsync({\n    latlng: `${options.latitude},${options.longitude}`,\n  });\n\n  if (result.status === 'ZERO_RESULTS') {\n    return [];\n  }\n  assertGeocodeResults(result);\n  return result.results.map(reverseGeocodingResultToAddress);\n}\n\n// https://developers.google.com/maps/documentation/geocoding/intro\nfunction assertGeocodeResults(resultObject: any): void {\n  const { status, error_message } = resultObject;\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(\n        status,\n        'the request could not be processed due to a server error. The request may succeed if you try again.'\n      );\n    }\n    throw new CodedError(status, `An error occurred during geocoding.`);\n  }\n}\n\n/**\n * Makes sure the Google API key is set.\n */\nfunction assertGoogleApiKey() {\n  if (!googleApiKey) {\n    throw new Error(\n      'Google API key is required to use geocoding. Please set it using `setGoogleApiKey` method.'\n    );\n  }\n}\n\n/**\n * Generic and handy method for sending requests to Google Maps API endpoint.\n */\nasync function requestGoogleApiAsync(\n  params: { address: string } | { latlng: string }\n): Promise<GoogleApiGeocodingResponse> {\n  const query = Object.entries(params)\n    .map((entry) => `${entry[0]}=${encodeURI(entry[1])}`)\n    .join('&');\n  const result = await fetch(`${GOOGLE_API_URL}?key=${googleApiKey}&${query}`);\n  return await result.json();\n}\n\n/**\n * Converts Google's result to the location object.\n */\nfunction geocodingResultToLocation(result: GoogleApiGeocodingResult): LocationGeocodedLocation {\n  const { location } = result.geometry;\n  return {\n    latitude: location.lat,\n    longitude: location.lng,\n  };\n}\n\n/**\n * Converts Google's result to address object.\n */\nfunction reverseGeocodingResultToAddress(\n  result: GoogleApiGeocodingResult\n): LocationGeocodedAddress {\n  const address: Partial<LocationGeocodedAddress> = {};\n\n  for (const { long_name, short_name, types } of result.address_components) {\n    if (types.includes('locality')) {\n      address.city = long_name;\n      continue;\n    }\n    if (types.includes('sublocality')) {\n      address.district = long_name;\n      continue;\n    }\n    if (types.includes('street_number')) {\n      address.streetNumber = long_name;\n      continue;\n    }\n    if (types.includes('street_address') || types.includes('route')) {\n      address.street = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_1')) {\n      address.region = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_2')) {\n      address.subregion = long_name;\n      continue;\n    }\n    if (types.includes('country')) {\n      address.country = long_name;\n      address.isoCountryCode = short_name;\n      continue;\n    }\n    if (types.includes('postal_code')) {\n      address.postalCode = long_name;\n      continue;\n    }\n    if (types.includes('point_of_interest')) {\n      address.name = long_name;\n      continue;\n    }\n  }\n  if (!address.name) {\n    address.name = result.formatted_address.replace(/,.*$/, '');\n  }\n  return address as LocationGeocodedAddress;\n}\n"]},"metadata":{},"sourceType":"module"}