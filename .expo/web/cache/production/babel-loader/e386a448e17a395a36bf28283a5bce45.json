{"ast":null,"code":"import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";import{PermissionStatus,createPermissionHook,Platform}from'expo-modules-core';import ExpoLocation from\"./ExpoLocation\";import{LocationAccuracy,LocationActivityType,LocationGeofencingEventType,LocationGeofencingRegionState}from\"./Location.types\";import{LocationEventEmitter}from\"./LocationEventEmitter\";import{setGoogleApiKey,googleGeocodeAsync,googleReverseGeocodeAsync}from\"./LocationGoogleGeocoding\";import{LocationSubscriber,HeadingSubscriber,_getCurrentWatchId}from\"./LocationSubscribers\";export function getProviderStatusAsync(){return _getProviderStatusAsync.apply(this,arguments);}function _getProviderStatusAsync(){_getProviderStatusAsync=_asyncToGenerator(function*(){return ExpoLocation.getProviderStatusAsync();});return _getProviderStatusAsync.apply(this,arguments);}export function enableNetworkProviderAsync(){return _enableNetworkProviderAsync.apply(this,arguments);}function _enableNetworkProviderAsync(){_enableNetworkProviderAsync=_asyncToGenerator(function*(){if(Platform.OS==='android'){return ExpoLocation.enableNetworkProviderAsync();}});return _enableNetworkProviderAsync.apply(this,arguments);}export function getCurrentPositionAsync(){return _getCurrentPositionAsync.apply(this,arguments);}function _getCurrentPositionAsync(){_getCurrentPositionAsync=_asyncToGenerator(function*(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return ExpoLocation.getCurrentPositionAsync(options);});return _getCurrentPositionAsync.apply(this,arguments);}export function getLastKnownPositionAsync(){return _getLastKnownPositionAsync.apply(this,arguments);}function _getLastKnownPositionAsync(){_getLastKnownPositionAsync=_asyncToGenerator(function*(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return ExpoLocation.getLastKnownPositionAsync(options);});return _getLastKnownPositionAsync.apply(this,arguments);}export function watchPositionAsync(_x,_x2){return _watchPositionAsync.apply(this,arguments);}function _watchPositionAsync(){_watchPositionAsync=_asyncToGenerator(function*(options,callback){var watchId=LocationSubscriber.registerCallback(callback);yield ExpoLocation.watchPositionImplAsync(watchId,options);return{remove:function remove(){LocationSubscriber.unregisterCallback(watchId);}};});return _watchPositionAsync.apply(this,arguments);}export function getHeadingAsync(){return _getHeadingAsync.apply(this,arguments);}function _getHeadingAsync(){_getHeadingAsync=_asyncToGenerator(function*(){return new Promise(function(){var _ref=_asyncToGenerator(function*(resolve){var tries=0;var subscription=yield watchHeadingAsync(function(heading){if(heading.accuracy>1||tries>5){subscription.remove();resolve(heading);}else{tries+=1;}});});return function(_x14){return _ref.apply(this,arguments);};}());});return _getHeadingAsync.apply(this,arguments);}export function watchHeadingAsync(_x3){return _watchHeadingAsync.apply(this,arguments);}function _watchHeadingAsync(){_watchHeadingAsync=_asyncToGenerator(function*(callback){var watchId=HeadingSubscriber.registerCallback(callback);yield ExpoLocation.watchDeviceHeading(watchId);return{remove:function remove(){HeadingSubscriber.unregisterCallback(watchId);}};});return _watchHeadingAsync.apply(this,arguments);}export function geocodeAsync(_x4,_x5){return _geocodeAsync.apply(this,arguments);}function _geocodeAsync(){_geocodeAsync=_asyncToGenerator(function*(address,options){if(typeof address!=='string'){throw new TypeError(\"Address to geocode must be a string. Got \"+address+\" instead.\");}if(options!=null&&options.useGoogleMaps||Platform.OS==='web'){return yield googleGeocodeAsync(address);}return yield ExpoLocation.geocodeAsync(address);});return _geocodeAsync.apply(this,arguments);}export function reverseGeocodeAsync(_x6,_x7){return _reverseGeocodeAsync.apply(this,arguments);}function _reverseGeocodeAsync(){_reverseGeocodeAsync=_asyncToGenerator(function*(location,options){if(typeof location.latitude!=='number'||typeof location.longitude!=='number'){throw new TypeError('Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.');}if(options!=null&&options.useGoogleMaps||Platform.OS==='web'){return yield googleReverseGeocodeAsync(location);}return yield ExpoLocation.reverseGeocodeAsync(location);});return _reverseGeocodeAsync.apply(this,arguments);}export function getPermissionsAsync(){return _getPermissionsAsync.apply(this,arguments);}function _getPermissionsAsync(){_getPermissionsAsync=_asyncToGenerator(function*(){console.warn(\"\\\"getPermissionsAsync()\\\" is now deprecated. Please use \\\"getForegroundPermissionsAsync()\\\" or \\\"getBackgroundPermissionsAsync()\\\" instead.\");return yield ExpoLocation.getPermissionsAsync();});return _getPermissionsAsync.apply(this,arguments);}export function requestPermissionsAsync(){return _requestPermissionsAsync.apply(this,arguments);}function _requestPermissionsAsync(){_requestPermissionsAsync=_asyncToGenerator(function*(){console.warn(\"\\\"requestPermissionsAsync()\\\" is now deprecated. Please use \\\"requestForegroundPermissionsAsync()\\\" or \\\"requestBackgroundPermissionsAsync()\\\" instead.\");return yield ExpoLocation.requestPermissionsAsync();});return _requestPermissionsAsync.apply(this,arguments);}export function getForegroundPermissionsAsync(){return _getForegroundPermissionsAsync.apply(this,arguments);}function _getForegroundPermissionsAsync(){_getForegroundPermissionsAsync=_asyncToGenerator(function*(){return yield ExpoLocation.getForegroundPermissionsAsync();});return _getForegroundPermissionsAsync.apply(this,arguments);}export function requestForegroundPermissionsAsync(){return _requestForegroundPermissionsAsync.apply(this,arguments);}function _requestForegroundPermissionsAsync(){_requestForegroundPermissionsAsync=_asyncToGenerator(function*(){return yield ExpoLocation.requestForegroundPermissionsAsync();});return _requestForegroundPermissionsAsync.apply(this,arguments);}export var useForegroundPermissions=createPermissionHook({getMethod:getForegroundPermissionsAsync,requestMethod:requestForegroundPermissionsAsync});export function getBackgroundPermissionsAsync(){return _getBackgroundPermissionsAsync.apply(this,arguments);}function _getBackgroundPermissionsAsync(){_getBackgroundPermissionsAsync=_asyncToGenerator(function*(){return yield ExpoLocation.getBackgroundPermissionsAsync();});return _getBackgroundPermissionsAsync.apply(this,arguments);}export function requestBackgroundPermissionsAsync(){return _requestBackgroundPermissionsAsync.apply(this,arguments);}function _requestBackgroundPermissionsAsync(){_requestBackgroundPermissionsAsync=_asyncToGenerator(function*(){return yield ExpoLocation.requestBackgroundPermissionsAsync();});return _requestBackgroundPermissionsAsync.apply(this,arguments);}export var useBackgroundPermissions=createPermissionHook({getMethod:getBackgroundPermissionsAsync,requestMethod:requestBackgroundPermissionsAsync});export function hasServicesEnabledAsync(){return _hasServicesEnabledAsync.apply(this,arguments);}function _hasServicesEnabledAsync(){_hasServicesEnabledAsync=_asyncToGenerator(function*(){return yield ExpoLocation.hasServicesEnabledAsync();});return _hasServicesEnabledAsync.apply(this,arguments);}function _validateTaskName(taskName){if(!taskName||typeof taskName!=='string'){throw new Error(\"`taskName` must be a non-empty string. Got \"+taskName+\" instead.\");}}export function isBackgroundLocationAvailableAsync(){return _isBackgroundLocationAvailableAsync.apply(this,arguments);}function _isBackgroundLocationAvailableAsync(){_isBackgroundLocationAvailableAsync=_asyncToGenerator(function*(){var providerStatus=yield getProviderStatusAsync();return providerStatus.backgroundModeEnabled;});return _isBackgroundLocationAvailableAsync.apply(this,arguments);}export function startLocationUpdatesAsync(_x8){return _startLocationUpdatesAsync.apply(this,arguments);}function _startLocationUpdatesAsync(){_startLocationUpdatesAsync=_asyncToGenerator(function*(taskName){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{accuracy:LocationAccuracy.Balanced};_validateTaskName(taskName);yield ExpoLocation.startLocationUpdatesAsync(taskName,options);});return _startLocationUpdatesAsync.apply(this,arguments);}export function stopLocationUpdatesAsync(_x9){return _stopLocationUpdatesAsync.apply(this,arguments);}function _stopLocationUpdatesAsync(){_stopLocationUpdatesAsync=_asyncToGenerator(function*(taskName){_validateTaskName(taskName);yield ExpoLocation.stopLocationUpdatesAsync(taskName);});return _stopLocationUpdatesAsync.apply(this,arguments);}export function hasStartedLocationUpdatesAsync(_x10){return _hasStartedLocationUpdatesAsync.apply(this,arguments);}function _hasStartedLocationUpdatesAsync(){_hasStartedLocationUpdatesAsync=_asyncToGenerator(function*(taskName){_validateTaskName(taskName);return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);});return _hasStartedLocationUpdatesAsync.apply(this,arguments);}function _validateRegions(regions){if(!regions||regions.length===0){throw new Error('Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions');}for(var region of regions){if(typeof region.latitude!=='number'){throw new TypeError(\"Region's latitude must be a number. Got '\"+region.latitude+\"' instead.\");}if(typeof region.longitude!=='number'){throw new TypeError(\"Region's longitude must be a number. Got '\"+region.longitude+\"' instead.\");}if(typeof region.radius!=='number'){throw new TypeError(\"Region's radius must be a number. Got '\"+region.radius+\"' instead.\");}}}export function startGeofencingAsync(_x11){return _startGeofencingAsync.apply(this,arguments);}function _startGeofencingAsync(){_startGeofencingAsync=_asyncToGenerator(function*(taskName){var regions=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];_validateTaskName(taskName);_validateRegions(regions);yield ExpoLocation.startGeofencingAsync(taskName,{regions:regions});});return _startGeofencingAsync.apply(this,arguments);}export function stopGeofencingAsync(_x12){return _stopGeofencingAsync.apply(this,arguments);}function _stopGeofencingAsync(){_stopGeofencingAsync=_asyncToGenerator(function*(taskName){_validateTaskName(taskName);yield ExpoLocation.stopGeofencingAsync(taskName);});return _stopGeofencingAsync.apply(this,arguments);}export function hasStartedGeofencingAsync(_x13){return _hasStartedGeofencingAsync.apply(this,arguments);}function _hasStartedGeofencingAsync(){_hasStartedGeofencingAsync=_asyncToGenerator(function*(taskName){_validateTaskName(taskName);return ExpoLocation.hasStartedGeofencingAsync(taskName);});return _hasStartedGeofencingAsync.apply(this,arguments);}export{LocationEventEmitter as EventEmitter,_getCurrentWatchId};export{LocationAccuracy as Accuracy,LocationActivityType as ActivityType,LocationGeofencingEventType as GeofencingEventType,LocationGeofencingRegionState as GeofencingRegionState,PermissionStatus,setGoogleApiKey};export{installWebGeolocationPolyfill}from\"./GeolocationPolyfill\";export*from\"./Location.types\";","map":{"version":3,"mappings":"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","names":["PermissionStatus","createPermissionHook","Platform","ExpoLocation","LocationAccuracy","LocationActivityType","LocationGeofencingEventType","LocationGeofencingRegionState","LocationEventEmitter","setGoogleApiKey","googleGeocodeAsync","googleReverseGeocodeAsync","LocationSubscriber","HeadingSubscriber","_getCurrentWatchId","getProviderStatusAsync","enableNetworkProviderAsync","OS","getCurrentPositionAsync","options","getLastKnownPositionAsync","watchPositionAsync","callback","watchId","registerCallback","watchPositionImplAsync","remove","unregisterCallback","getHeadingAsync","Promise","resolve","tries","subscription","watchHeadingAsync","heading","accuracy","watchDeviceHeading","geocodeAsync","address","TypeError","useGoogleMaps","reverseGeocodeAsync","location","latitude","longitude","getPermissionsAsync","console","warn","requestPermissionsAsync","getForegroundPermissionsAsync","requestForegroundPermissionsAsync","useForegroundPermissions","getMethod","requestMethod","getBackgroundPermissionsAsync","requestBackgroundPermissionsAsync","useBackgroundPermissions","hasServicesEnabledAsync","_validateTaskName","taskName","Error","isBackgroundLocationAvailableAsync","providerStatus","backgroundModeEnabled","startLocationUpdatesAsync","Balanced","stopLocationUpdatesAsync","hasStartedLocationUpdatesAsync","_validateRegions","regions","length","region","radius","startGeofencingAsync","stopGeofencingAsync","hasStartedGeofencingAsync","EventEmitter","Accuracy","ActivityType","GeofencingEventType","GeofencingRegionState","installWebGeolocationPolyfill"],"sourceRoot":"","sources":["../src/Location.ts"],"sourcesContent":["import {\n  PermissionStatus,\n  PermissionResponse,\n  PermissionHookOptions,\n  createPermissionHook,\n  Platform,\n} from 'expo-modules-core';\n\nimport ExpoLocation from './ExpoLocation';\nimport {\n  LocationAccuracy,\n  LocationCallback,\n  LocationGeocodedAddress,\n  LocationGeocodedLocation,\n  LocationHeadingCallback,\n  LocationHeadingObject,\n  LocationLastKnownOptions,\n  LocationObject,\n  LocationOptions,\n  LocationPermissionResponse,\n  LocationProviderStatus,\n  LocationRegion,\n  LocationSubscription,\n  LocationTaskOptions,\n  LocationActivityType,\n  LocationGeofencingEventType,\n  LocationGeofencingRegionState,\n  LocationGeocodingOptions,\n} from './Location.types';\nimport { LocationEventEmitter } from './LocationEventEmitter';\nimport {\n  setGoogleApiKey,\n  googleGeocodeAsync,\n  googleReverseGeocodeAsync,\n} from './LocationGoogleGeocoding';\nimport { LocationSubscriber, HeadingSubscriber, _getCurrentWatchId } from './LocationSubscribers';\n\n// @needsAudit\n/**\n * Check status of location providers.\n * @return A promise which fulfills with an object of type [LocationProviderStatus](#locationproviderstatus).\n */\nexport async function getProviderStatusAsync(): Promise<LocationProviderStatus> {\n  return ExpoLocation.getProviderStatusAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to turn on high accuracy location mode which enables network provider that uses\n * Google Play services to improve location accuracy and location-based services.\n * @return A promise resolving as soon as the user accepts the dialog. Rejects if denied.\n */\nexport async function enableNetworkProviderAsync(): Promise<void> {\n  // If network provider is disabled (user's location mode is set to \"Device only\"),\n  // Android's location provider may not give you any results. Use this method in order to ask the user\n  // to change the location mode to \"High accuracy\" which uses Google Play services and enables network provider.\n  // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.\n\n  if (Platform.OS === 'android') {\n    return ExpoLocation.enableNetworkProviderAsync();\n  }\n}\n\n// @needsAudit\n/**\n * Requests for one-time delivery of the user's current location.\n * Depending on given `accuracy` option it may take some time to resolve,\n * especially when you're inside a building.\n * > __Note:__ Calling it causes the location manager to obtain a location fix which may take several\n * > seconds. Consider using [`Location.getLastKnownPositionAsync`](#locationgetlastknownpositionasyncoptions)\n * > if you expect to get a quick response and high accuracy is not required.\n * @param options\n * @return A promise which fulfills with an object of type [`LocationObject`](#locationobject).\n */\nexport async function getCurrentPositionAsync(\n  options: LocationOptions = {}\n): Promise<LocationObject> {\n  return ExpoLocation.getCurrentPositionAsync(options);\n}\n\n// @needsAudit\n/**\n * Gets the last known position of the device or `null` if it's not available or doesn't match given\n * requirements such as maximum age or required accuracy.\n * It's considered to be faster than `getCurrentPositionAsync` as it doesn't request for the current\n * location, but keep in mind the returned location may not be up-to-date.\n * @param options\n * @return A promise which fulfills with an object of type [LocationObject](#locationobject) or\n * `null` if it's not available or doesn't match given requirements such as maximum age or required\n * accuracy.\n */\nexport async function getLastKnownPositionAsync(\n  options: LocationLastKnownOptions = {}\n): Promise<LocationObject | null> {\n  return ExpoLocation.getLastKnownPositionAsync(options);\n}\n\n// @needsAudit\n/**\n * Subscribe to location updates from the device. Please note that updates will only occur while the\n * application is in the foreground. To get location updates while in background you'll need to use\n * [Location.startLocationUpdatesAsync](#locationstartlocationupdatesasynctaskname-options).\n * @param options\n * @param callback This function is called on each location update. It receives an object of type\n * [`LocationObject`](#locationobject) as the first argument.\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\n */\nexport async function watchPositionAsync(\n  options: LocationOptions,\n  callback: LocationCallback\n): Promise<LocationSubscription> {\n  const watchId = LocationSubscriber.registerCallback(callback);\n  await ExpoLocation.watchPositionImplAsync(watchId, options);\n\n  return {\n    remove() {\n      LocationSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n// @needsAudit\n/**\n * Gets the current heading information from the device. To simplify, it calls `watchHeadingAsync`\n * and waits for a couple of updates, and then returns the one that is accurate enough.\n * @return A promise which fulfills with an object of type [LocationHeadingObject](#locationheadingobject).\n */\nexport async function getHeadingAsync(): Promise<LocationHeadingObject> {\n  return new Promise(async (resolve) => {\n    let tries = 0;\n\n    const subscription = await watchHeadingAsync((heading) => {\n      if (heading.accuracy > 1 || tries > 5) {\n        subscription.remove();\n        resolve(heading);\n      } else {\n        tries += 1;\n      }\n    });\n  });\n}\n\n// @needsAudit\n/**\n * Subscribe to compass updates from the device.\n * @param callback This function is called on each compass update. It receives an object of type\n * [LocationHeadingObject](#locationheadingobject) as the first argument.\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\n */\nexport async function watchHeadingAsync(\n  callback: LocationHeadingCallback\n): Promise<LocationSubscription> {\n  const watchId = HeadingSubscriber.registerCallback(callback);\n  await ExpoLocation.watchDeviceHeading(watchId);\n\n  return {\n    remove() {\n      HeadingSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n// @needsAudit\n/**\n * Geocode an address string to latitude-longitude location.\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\n * > requests at a time can result in an error, so they have to be managed properly.\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\n * > be shown to the user immediately.\n *\n * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user\n * > before geocoding can be used.\n * @param address A string representing address, eg. `\"Baker Street London\"`.\n * @param options\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedLocation`](#locationgeocodedlocation) objects.\n */\nexport async function geocodeAsync(\n  address: string,\n  options?: LocationGeocodingOptions\n): Promise<LocationGeocodedLocation[]> {\n  if (typeof address !== 'string') {\n    throw new TypeError(`Address to geocode must be a string. Got ${address} instead.`);\n  }\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\n    return await googleGeocodeAsync(address);\n  }\n  return await ExpoLocation.geocodeAsync(address);\n}\n\n// @needsAudit\n/**\n * Reverse geocode a location to postal address.\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\n * > requests at a time can result in an error, so they have to be managed properly.\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\n * > be shown to the user immediately.\n *\n * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user\n * > before geocoding can be used.\n * @param location An object representing a location.\n * @param options\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedAddress`](#locationgeocodedaddress) objects.\n */\nexport async function reverseGeocodeAsync(\n  location: Pick<LocationGeocodedLocation, 'latitude' | 'longitude'>,\n  options?: LocationGeocodingOptions\n): Promise<LocationGeocodedAddress[]> {\n  if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n    throw new TypeError(\n      'Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.'\n    );\n  }\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\n    return await googleReverseGeocodeAsync(location);\n  }\n  return await ExpoLocation.reverseGeocodeAsync(location);\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location.\n * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).\n * @deprecated Use [`getForegroundPermissionsAsync`](#locationgetforegroundpermissionsasync) or [`getBackgroundPermissionsAsync`](#locationgetbackgroundpermissionsasync) instead.\n */\nexport async function getPermissionsAsync(): Promise<LocationPermissionResponse> {\n  console.warn(\n    `\"getPermissionsAsync()\" is now deprecated. Please use \"getForegroundPermissionsAsync()\" or \"getBackgroundPermissionsAsync()\" instead.`\n  );\n  return await ExpoLocation.getPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location.\n * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).\n * @deprecated Use [`requestForegroundPermissionsAsync`](#locationrequestforegroundpermissionsasync) or [`requestBackgroundPermissionsAsync`](#locationrequestbackgroundpermissionsasync) instead.\n */\nexport async function requestPermissionsAsync(): Promise<LocationPermissionResponse> {\n  console.warn(\n    `\"requestPermissionsAsync()\" is now deprecated. Please use \"requestForegroundPermissionsAsync()\" or \"requestBackgroundPermissionsAsync()\" instead.`\n  );\n\n  return await ExpoLocation.requestPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location while the app is in the foreground.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function getForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.getForegroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location while the app is in the foreground.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function requestForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.requestForegroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions for the foreground location.\n * This uses both `requestForegroundPermissionsAsync` and `getForegroundPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Location.useForegroundPermissions();\n * ```\n */\nexport const useForegroundPermissions = createPermissionHook({\n  getMethod: getForegroundPermissionsAsync,\n  requestMethod: requestForegroundPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location while the app is in the background.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function getBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.getBackgroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location while the app is in the background.\n * On __Android 11 or higher__: this method will open the system settings page - before that happens\n * you should explain to the user why your application needs background location permission.\n * For example, you can use `Modal` component from `react-native` to do that.\n * > __Note__: Foreground permissions should be granted before asking for the background permissions\n * (your app can't obtain background permission without foreground permission).\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function requestBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.requestBackgroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions for the foreground location.\n * This uses both `requestBackgroundPermissionsAsync` and `getBackgroundPermissionsAsync` to\n * interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Location.useBackgroundPermissions();\n * ```\n */\nexport const useBackgroundPermissions = createPermissionHook({\n  getMethod: getBackgroundPermissionsAsync,\n  requestMethod: requestBackgroundPermissionsAsync,\n});\n\n// --- Location service\n\n// @needsAudit\n/**\n * Checks whether location services are enabled by the user.\n * @return A promise which fulfills to `true` if location services are enabled on the device,\n * or `false` if not.\n */\nexport async function hasServicesEnabledAsync(): Promise<boolean> {\n  return await ExpoLocation.hasServicesEnabledAsync();\n}\n\n// --- Background location updates\n\nfunction _validateTaskName(taskName: string) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new Error(`\\`taskName\\` must be a non-empty string. Got ${taskName} instead.`);\n  }\n}\n\n// @docsMissing\nexport async function isBackgroundLocationAvailableAsync(): Promise<boolean> {\n  const providerStatus = await getProviderStatusAsync();\n  return providerStatus.backgroundModeEnabled;\n}\n\n// @needsAudit\n/**\n * Registers for receiving location updates that can also come when the app is in the background.\n *\n * # Task parameters\n *\n * Background location task will be receiving following data:\n * - `locations` - An array of the new locations.\n *\n * ```ts\n * import * as TaskManager from 'expo-task-manager';\n *\n * TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { locations }, error }) => {\n *  if (error) {\n *    // check `error.message` for more details.\n *    return;\n *  }\n *  console.log('Received new locations', locations);\n * });\n * ```\n *\n * @param taskName Name of the task receiving location updates.\n * @param options An object of options passed to the location manager.\n *\n * @return A promise resolving once the task with location updates is registered.\n */\nexport async function startLocationUpdatesAsync(\n  taskName: string,\n  options: LocationTaskOptions = { accuracy: LocationAccuracy.Balanced }\n): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.startLocationUpdatesAsync(taskName, options);\n}\n\n// @needsAudit\n/**\n * Stops geofencing for specified task.\n * @param taskName Name of the background location task to stop.\n * @return A promise resolving as soon as the task is unregistered.\n */\nexport async function stopLocationUpdatesAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopLocationUpdatesAsync(taskName);\n}\n\n// @needsAudit\n/**\n * @param taskName Name of the location task to check.\n * @return A promise which fulfills with boolean value indicating whether the location task is\n * started or not.\n */\nexport async function hasStartedLocationUpdatesAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n}\n\n// --- Geofencing\n\nfunction _validateRegions(regions: LocationRegion[]) {\n  if (!regions || regions.length === 0) {\n    throw new Error(\n      'Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions'\n    );\n  }\n  for (const region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\n        `Region's longitude must be a number. Got '${region.longitude}' instead.`\n      );\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\n    }\n  }\n}\n\n// @needsAudit\n/**\n * Starts geofencing for given regions. When the new event comes, the task with specified name will\n * be called with the region that the device enter to or exit from.\n * If you want to add or remove regions from already running geofencing task, you can just call\n * `startGeofencingAsync` again with the new array of regions.\n *\n * # Task parameters\n *\n * Geofencing task will be receiving following data:\n *  - `eventType` - Indicates the reason for calling the task, which can be triggered by entering or exiting the region.\n *    See [GeofencingEventType](#geofencingeventtype).\n *  - `region` - Object containing details about updated region. See [LocationRegion](#locationregion) for more details.\n *\n * @param taskName Name of the task that will be called when the device enters or exits from specified regions.\n * @param regions Array of region objects to be geofenced.\n *\n * @return A promise resolving as soon as the task is registered.\n *\n * @example\n * ```ts\n * import { GeofencingEventType } from 'expo-location';\n * import * as TaskManager from 'expo-task-manager';\n *\n *  TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { eventType, region }, error }) => {\n *   if (error) {\n *     // check `error.message` for more details.\n *     return;\n *   }\n *   if (eventType === GeofencingEventType.Enter) {\n *     console.log(\"You've entered region:\", region);\n *   } else if (eventType === GeofencingEventType.Exit) {\n *     console.log(\"You've left region:\", region);\n *   }\n * });\n * ```\n */\nexport async function startGeofencingAsync(\n  taskName: string,\n  regions: LocationRegion[] = []\n): Promise<void> {\n  _validateTaskName(taskName);\n  _validateRegions(regions);\n  await ExpoLocation.startGeofencingAsync(taskName, { regions });\n}\n\n// @needsAudit\n/**\n * Stops geofencing for specified task. It unregisters the background task so the app will not be\n * receiving any updates, especially in the background.\n * @param taskName Name of the task to unregister.\n * @return A promise resolving as soon as the task is unregistered.\n */\nexport async function stopGeofencingAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopGeofencingAsync(taskName);\n}\n\n// @needsAudit\n/**\n * @param taskName Name of the geofencing task to check.\n * @return A promise which fulfills with boolean value indicating whether the geofencing task is\n * started or not.\n */\nexport async function hasStartedGeofencingAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedGeofencingAsync(taskName);\n}\n\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };\n\nexport {\n  LocationAccuracy as Accuracy,\n  LocationActivityType as ActivityType,\n  LocationGeofencingEventType as GeofencingEventType,\n  LocationGeofencingRegionState as GeofencingRegionState,\n  PermissionStatus,\n  PermissionHookOptions,\n  setGoogleApiKey,\n};\n\nexport { installWebGeolocationPolyfill } from './GeolocationPolyfill';\nexport * from './Location.types';\n"]},"metadata":{},"sourceType":"module"}